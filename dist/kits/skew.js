// Generated by LiveScript 1.3.1
(function(){
  var easingFit, cubic, anikit, ret;
  if (typeof require != 'undefined' && require !== null) {
    easingFit = require('easing-fit');
    cubic = require('cubic');
    anikit = require('../anikit');
  }
  ret = {
    name: 'skew',
    type: 'animation',
    preset: {
      "skew": {},
      "skew-alt": {
        dir: 90
      }
    },
    edit: {
      dir: {
        type: 'number',
        'default': 0,
        min: 0,
        max: 90,
        step: 1
      },
      deg: {
        type: 'number',
        'default': 20,
        min: 0,
        max: 60,
        step: 0.1
      },
      scale: {
        type: 'number',
        'default': 0.1,
        min: 0,
        max: 1,
        step: 0.01
      },
      steep: {
        'default': 0.4,
        type: 'number',
        min: 0,
        max: 1,
        step: 0.01
      }
    },
    css: function(opt){
      var ds, s, c;
      ds = 1 - opt.scale;
      s = opt.steep;
      c = opt.dir === 0 ? 'X' : 'Y';
      return "@keyframes " + opt.name + " {\n  0%, 50%, 100% { animation-timing-function: cubic-bezier(" + s + ",0,1," + (1 - s) + ") }\n  25%, 75% {      animation-timing-function: cubic-bezier(0," + s + "," + (1 - s) + ",1) }\n    0% { transform: skew" + c + "(" + opt.deg + "deg) scale(1) }\n   25% { transform: skew" + c + "(0deg) scale(" + ds + ") }\n   50% { transform: skew" + c + "(-" + opt.deg + "deg) scale(1) }\n   75% { transform: skew" + c + "(0deg) scale(" + ds + ") }\n  100% { transform: skew" + c + "(" + opt.deg + "deg) scale(1) }\n}";
    },
    js: function(t, opt){
      var v, m;
      v = this.affine(t, opt, true);
      m = anikit.util.m4to3(v.transform);
      return {
        transform: "matrix(" + m.join(',') + ")"
      };
    },
    affine: function(t, opt, inverse){
      var ds, s, p1, p2, phase, dt, p, a, sx, sy;
      ds = 1 - opt.scale;
      s = opt.steep;
      p1 = [s, 0, 1, 1 - s];
      p2 = [0, s, 1 - s, 1];
      phase = Math.floor(t * 4);
      dt = t * 4 - phase;
      p = phase % 2 ? p2 : p1;
      t = cubic.Bezier.y(cubic.Bezier.t(dt, p), p);
      s = phase % 2
        ? (1 - ds) * t + ds
        : (ds - 1) * t + 1;
      a = (phase % 2
        ? opt.deg * t
        : opt.deg * (1 - t)) * Math.PI / 180;
      if (phase >= 1 && phase < 3) {
        a = -a;
      }
      sx = sy = -Math.tan(a);
      if (inverse) {
        sx = sy = -sx;
      }
      if (opt.dir === 0) {
        sy = 0;
      } else {
        sx = 0;
      }
      return {
        transform: [s, sy, 0, 0, sx, s, 0, 0, 0, 0, s, 0, 0, 0, 0, 1]
      };
    }
  };
  if (typeof module != 'undefined' && module !== null) {
    module.exports = ret;
  }
  return ret;
})();