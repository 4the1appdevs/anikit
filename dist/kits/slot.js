// Generated by LiveScript 1.3.1
var easingFit, cubic, anikit, ret;
easingFit = require('easing-fit');
cubic = require('cubic');
anikit = require('../anikit');
ret = {
  name: 'slot',
  type: 'animation',
  debug: true,
  preset: {
    slot: {
      dur: 5,
      local: {
        segSampleCount: 3,
        sampleCount: 5000,
        errorThreshold: 0.00001
      },
      prop: function(f, c){
        return {
          transform: "matrix(" + anikit.util.m4to3(this.value(f.value, c).transform).join(',') + ")"
        };
      },
      value: function(t, c){
        t = t * c.amount + 0.5;
        t = t - Math.floor(t);
        return {
          transform: anikit.util.ty((t - 0.5) * c.offset)
        };
      }
    },
    roulette: {
      dur: 5,
      offset: {
        'default': 0,
        hidden: true
      },
      local: {
        segSampleCount: 40,
        sampleCount: 200,
        errorThreshold: 0.001
      },
      prop: function(f, c){
        return {
          transform: "rotate(" + f.value * c.amount * 360 + "deg)"
        };
      },
      value: function(t, c){
        return {
          transform: anikit.util.rz(t * c.amount * Math.PI * 2)
        };
      }
    }
  },
  edit: {
    steep: {
      'default': 0.5,
      type: 'number',
      min: 0,
      max: 1,
      step: 0.01
    },
    amount: {
      'default': 50,
      type: 'number',
      min: 0,
      max: 100,
      step: 1
    },
    offset: {
      'default': 200,
      type: 'number',
      min: 0,
      max: 1000,
      step: 1
    }
  },
  timing: function(t, opt){
    var max, min;
    max = 1 / (1 + Math.exp(-0.5 * (7 + 10 * opt.steep)));
    min = 1 / (1 + Math.exp(0.5 * (7 + 10 * opt.steep)));
    t = 1 / (1 + Math.exp(-(t - 0.5) * (7 + 10 * opt.steep)));
    return (t - min) / (max - min);
  },
  css: function(opt){
    var prop, ref$, ref1$, this$ = this;
    prop = function(f, c){
      return opt.prop(f, c);
    };
    return easingFit.fitToKeyframes(function(it){
      return this$.timing(it, opt);
    }, (ref$ = (ref1$ = import$({}, opt.local) || {}, ref1$.prop = prop, ref1$.config = opt, ref1$), ref$.name = opt.name, ref$));
  },
  js: function(t, opt){
    var value;
    value = this.affine(t, opt);
    return {
      transform: "matrix(" + anikit.util.m4to3(value.transform).join(',') + ")"
    };
  },
  affine: function(t, opt){
    return opt.value(this.timing(t, opt), opt);
  }
  /*
  css: (opt) ->
    prop = (f, c) -> return transform: "rotate(#{f.value * c.amount * 360}deg)"
    easing-fit.fit-to-keyframes (~> @timing it, opt), ({} <<< opt.local or {}) <<< {prop, config: opt} <<< opt{name}
  js: (t, opt) -> 
    value = @affine t, opt
    return transform: "matrix(#{anikit.util.m4to3(value.transform).join(',')})"
  affine: (t, opt) ->
    return transform: anikit.util.rz(@timing(t,opt) * opt.amount * Math.PI * 2)
  */
};
module.exports = ret;
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}