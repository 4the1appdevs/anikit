// Generated by LiveScript 1.3.1
var easingFit, cubic, anikit, ret;
easingFit = require('easing-fit');
cubic = require('cubic');
anikit = require('../anikit');
ret = {
  name: 'slot',
  type: 'animation',
  debug: true,
  preset: {
    slot: {
      dur: 5,
      local: {
        segSampleCount: 3,
        sampleCount: 100000,
        errorThreshold: 0.0005
      },
      prop: function(f, c){
        return {
          transform: "translate(0, " + (f.value - 0.5) * c.offset + c.unit + ")"
        };
      },
      value: function(t, c){
        t = t * c.amount + 0.5;
        t = t - Math.floor(t);
        return {
          transform: anikit.util.ty((t - 0.5) * c.offset)
        };
      }
    },
    roulette: {
      dur: 5,
      offset: {
        'default': 0,
        hidden: true
      },
      local: {
        segSampleCount: 10,
        sampleCount: 1000,
        errorThreshold: 0.001
      },
      prop: function(f, c){
        return {
          transform: "rotate(" + f.value * c.amount * 360 + "deg)"
        };
      },
      value: function(t, c){
        return {
          transform: anikit.util.rz(t * c.amount * Math.PI * 2)
        };
      }
    }
  },
  edit: {
    steep: {
      'default': 0.5,
      type: 'number',
      min: 0,
      max: 1,
      step: 0.01
    },
    amount: {
      'default': 50,
      type: 'number',
      min: 0,
      max: 100,
      step: 1
    },
    offset: {
      'default': 200,
      type: 'number',
      min: 0,
      max: 1000,
      step: 1
    },
    unit: {
      'default': 'px',
      type: 'choice',
      values: ['px', '%', '']
    }
  },
  timing: function(t, opt){
    var max, min;
    max = 1 / (1 + Math.exp(-0.5 * (7 + 10 * opt.steep)));
    min = 1 / (1 + Math.exp(0.5 * (7 + 10 * opt.steep)));
    t = 1 / (1 + Math.exp(-(t - 0.5) * (7 + 10 * opt.steep)));
    return (t - min) / (max - min);
  },
  css: function(opt){
    var prop, timing, ref$, ref1$, this$ = this;
    prop = function(f, c){
      return opt.prop(f, c);
    };
    if (opt.offset) {
      console.log(123);
      timing = function(t, opt){
        t = this$.timing(t, opt);
        t = t * opt.amount + 0.5;
        return t = t - Math.floor(t);
      };
    } else {
      timing = this.timing;
    }
    return easingFit.fitToKeyframes(function(it){
      return timing(it, opt);
    }, (ref$ = (ref1$ = import$({}, opt.local) || {}, ref1$.prop = prop, ref1$.config = opt, ref1$), ref$.name = opt.name, ref$));
  },
  js: function(t, opt){
    return {
      transform: "matrix(" + anikit.util.m4to3(this.affine(t, opt).transform).join(',') + ")"
    };
  },
  affine: function(t, opt){
    return opt.value(this.timing(t, opt), opt);
  }
};
module.exports = ret;
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}