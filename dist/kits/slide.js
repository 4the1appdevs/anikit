// Generated by LiveScript 1.3.1
var easingFit, cubic, anikit, ret;
easingFit = require('easing-fit');
cubic = require('cubic');
anikit = require('../anikit');
ret = {
  name: 'slide',
  type: 'animation',
  preset: {
    "slide-ltr": {
      local: {
        errorThreshold: 0.0001,
        sampleCount: 20
      },
      offset: 200,
      prop: function(f, c){
        return {
          transform: "translate(" + f.value * c.offset + c.unit + ",0)",
          opacity: f.value <= -0.8 || f.value >= 0.8 ? 0 : 1
        };
      },
      value: function(t, c){
        return {
          transform: anikit.util.tx(t * c.offset),
          opacity: t <= -0.8 || t >= 0.8 ? 0 : 1
        };
      }
    },
    "slide-rtl": {
      local: {
        errorThreshold: 0.0001,
        sampleCount: 20
      },
      offset: -200,
      prop: function(f, c){
        return {
          transform: "translate(" + f.value * c.offset + c.unit + ",0)",
          opacity: f.value <= -0.8 || f.value >= 0.8 ? 0 : 1
        };
      },
      value: function(t, c){
        return {
          transform: anikit.util.tx(t * c.offset),
          opacity: t <= -0.8 || t >= 0.8 ? 0 : 1
        };
      }
    },
    "slide-btt": {
      local: {
        errorThreshold: 0.0001,
        sampleCount: 20
      },
      offset: -200,
      prop: function(f, c){
        return {
          transform: "translate(0," + f.value * c.offset + c.unit + ")",
          opacity: f.value <= -0.8 || f.value >= 0.8 ? 0 : 1
        };
      },
      value: function(t, c){
        return {
          transform: anikit.util.ty(t * c.offset),
          opacity: t <= -0.8 || t >= 0.8 ? 0 : 1
        };
      }
    },
    "slide-ttb": {
      local: {
        errorThreshold: 0.0001,
        sampleCount: 20
      },
      offset: 200,
      prop: function(f, c){
        return {
          transform: "translate(0," + f.value * c.offset + c.unit + ")",
          opacity: f.value <= -0.8 || f.value >= 0.8 ? 0 : 1
        };
      },
      value: function(t, c){
        return {
          transform: anikit.util.ty(t * c.offset),
          opacity: t <= -0.8 || t >= 0.8 ? 0 : 1
        };
      }
    }
  },
  edit: {
    steep: {
      'default': 0.3,
      type: 'number',
      min: 0.3,
      max: 1,
      step: 0.01
    },
    offset: {
      'default': 200,
      type: 'number',
      unit: 'px',
      min: -2000,
      max: 2000
    },
    unit: {
      'default': 'px',
      type: 'choice',
      values: ["px", "%", ""]
    }
  },
  timing: function(t, opt){
    var p1, p2;
    p1 = [opt.steep, 0, 1, 1 - opt.steep];
    p2 = [0, opt.steep, 1 - opt.steep, 1];
    if (t < 0.5) {
      t = cubic.Bezier.y(cubic.Bezier.t(t * 2, p1), p1);
    } else {
      t = cubic.Bezier.y(cubic.Bezier.t((t - 0.5) * 2, p2), p2) / 2;
      t = t * 2 - 1;
    }
    return t;
  }
  /*
  css: (opt) -> anikit.step-to-keyframes (~> @timing it, opt), opt
  js: (t, opt) -> opt.prop {value: @timing t, opt}, opt
  */,
  css: function(opt){
    var ref$, ref1$, this$ = this;
    return easingFit.fitToKeyframes(function(it){
      return this$.timing(it, opt);
    }, (ref$ = (ref1$ = opt.local || {}, ref1$.config = opt, ref1$), ref$.name = opt.name, ref$.prop = opt.prop, ref$));
  },
  js: function(t, opt){
    return opt.prop({
      value: this.timing(t, opt)
    }, opt);
  },
  affine: function(t, opt){
    return opt.value(this.timing(t, opt), opt);
  }
  /* equivalent keyframes */
  /*
  slide(name, dur, rate, offset, func)
    .{name}
      animation: unquote(name) dur linear infinite
    @keyframes {name}
      0%, 100%
        timing-speed-up(rate)
      50%
        timing-speed-down(rate)
      0%
        func(0)
      49.9%
        func(offset)
      50%
        func(-1 * offset)
      100%
        func(0)
  */
};
module.exports = ret;