// Generated by LiveScript 1.3.1
var easingFit, cubic, anikit, easing, ret;
easingFit = require('easing-fit');
cubic = require('cubic');
anikit = require('../anikit');
easing = require('../easing');
ret = {
  name: 'power',
  type: 'animation',
  preset: {
    "power-off": {
      dir: -1,
      repeat: 1
    },
    "power-on": {
      dir: 1,
      repeat: 1
    }
  },
  edit: {
    steep: {
      'default': 0.5,
      type: 'number',
      min: 0,
      max: 1,
      step: 0.01
    },
    dir: {
      'default': 1,
      hidden: true
    }
  },
  local: {
    value: function(t, c){
      var ref$, x, y, o;
      if (c.dir > 0) {
        if (t < 0.2) {
          ref$ = [t * 5, 0.05], x = ref$[0], y = ref$[1];
        } else {
          ref$ = [1, 1.25 * (t - 0.2)], x = ref$[0], y = ref$[1];
        }
        o = t < 0.01 ? 0 : 1;
      } else {
        if (t < 0.2) {
          ref$ = [1, 1 - 5 * 0.95 * t], x = ref$[0], y = ref$[1];
        } else {
          ref$ = [1 - 1.25 * 0.95 * (t - 0.2), 0.05], x = ref$[0], y = ref$[1];
        }
        o = t > 0.95 ? 0 : 1;
      }
      return {
        transform: [x, 0, 0, 0, 0, y, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        opacity: o
      };
    }
  },
  timing: function(t, opt){
    var p;
    p = [0, opt.steep, 1 - opt.steep, 1];
    if (t < 0.2) {
      return t = cubic.Bezier.y(cubic.Bezier.t(t * 5, p), p) * 0.2;
    } else {
      return t = cubic.Bezier.y(cubic.Bezier.t((t - 0.2) * 1.25, p), p) * 0.8 + 0.2;
    }
  },
  css: function(opt){
    var ret;
    ret = "@keyframes " + opt.name + " {\n  0%, 20%, 100% {\n    animation-timing-function: cubic-bezier(0," + opt.steep + "," + (1 - opt.steep) + ",1);\n  }\n  " + (opt.dir > 0 ? 0 : 100) + "% { transform: scale(0,0); opacity: 0}\n  " + (opt.dir > 0 ? 1 : 99) + "% { transform: scale(0.05,0.05); opacity: 1 }\n  " + (opt.dir < 0 ? 0 : 100) + "% { transform: scale(1,1); opacity: 1 }\n  20% { transform: scale(1,0.1); }\n}";
    return ret;
  },
  js: function(t, opt){
    var value, ref$, o, m;
    value = this.local.value(this.timing(t, opt), opt);
    ref$ = [value.opacity, anikit.util.m4to3(value.transform)], o = ref$[0], m = ref$[1];
    return {
      transform: "matrix(" + m.join(',') + ")",
      opacity: o
    };
  },
  affine: function(t, opt){
    return this.local.value(this.timing(t, opt), opt);
  }
};
module.exports = ret;