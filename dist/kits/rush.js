// Generated by LiveScript 1.3.1
(function(){
  var easingFit, cubic, anikit, rushH, rushV, ret;
  if (typeof require != 'undefined' && require !== null) {
    easingFit = require('easing-fit');
    cubic = require('cubic');
    anikit = require('../anikit');
  }
  rushH = {
    prop: function(f, c){
      return {
        transform: "translate(" + f.value * c.offset_far * c.direction + c.unit + ",0)\nskew(" + f.value * c.skew * -c.direction + "deg)",
        opacity: Math.cos(f.value * Math.PI * 0.5)
      };
    },
    value: function(t, c){
      return {
        transform: [1, -Math.tan(t * c.skew * -c.direction * Math.PI / 180), 0, t * c.offset_far * c.direction, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        opacity: Math.cos(t * Math.PI * 0.5)
      };
    }
  };
  rushV = {
    prop: function(f, c){
      return {
        transform: "translate(0," + f.value * c.offset_far * c.direction + c.unit + ")\nskewY(" + f.value * c.skew * c.direction + "deg)",
        opacity: Math.cos(f.value * Math.PI * 0.5)
      };
    },
    value: function(t, c){
      return {
        transform: [1, -Math.tan(t * c.skew * c.direction * Math.PI / 180), 0, 0, 0, 1, 0, -t * c.offset_far * c.direction, 0, 0, 1, 0, 0, 0, 0, 1],
        opacity: Math.cos(t * Math.PI * 0.5)
      };
    }
  };
  ret = {
    name: 'rush',
    type: 'animation',
    preset: {
      "rush-btt-in": {
        repeat: 1,
        direction: -1,
        percent_in: 0.9,
        local: {
          sampleCount: 40,
          errorThreshold: 0.001
        },
        percent_out: {
          'default': 1,
          hidden: true
        },
        prop: function(f, c){
          return rushV.prop(f, c);
        },
        value: function(t, c){
          return rushV.value(t, c);
        }
      },
      "rush-ttb-in": {
        repeat: 1,
        direction: 1,
        percent_in: 0.9,
        local: {
          sampleCount: 40,
          errorThreshold: 0.001
        },
        percent_out: {
          'default': 1,
          hidden: true
        },
        prop: function(f, c){
          return rushV.prop(f, c);
        },
        value: function(t, c){
          return rushV.value(t, c);
        }
      },
      "rush-ltr-in": {
        repeat: 1,
        direction: 1,
        percent_in: 0.9,
        local: {
          sampleCount: 40,
          errorThreshold: 0.001
        },
        percent_out: {
          'default': 1,
          hidden: true
        },
        prop: function(f, c){
          return rushH.prop(f, c);
        },
        value: function(t, c){
          return rushH.value(t, c);
        }
      },
      "rush-rtl-in": {
        repeat: 1,
        direction: -1,
        percent_in: 0.9,
        local: {
          sampleCount: 40,
          errorThreshold: 0.001
        },
        percent_out: {
          'default': 1,
          hidden: true
        },
        prop: function(f, c){
          return rushH.prop(f, c);
        },
        value: function(t, c){
          return rushH.value(t, c);
        }
      },
      "rush-btt": {
        direction: -1,
        local: {
          sampleCount: 40,
          errorThreshold: 0.001
        },
        prop: function(f, c){
          return rushV.prop(f, c);
        },
        value: function(t, c){
          return rushV.value(t, c);
        }
      },
      "rush-ttb": {
        direction: 1,
        local: {
          sampleCount: 40,
          errorThreshold: 0.001
        },
        prop: function(f, c){
          return rushV.prop(f, c);
        },
        value: function(t, c){
          return rushV.value(t, c);
        }
      },
      "rush-rtl": {
        direction: -1,
        local: {
          sampleCount: 40,
          errorThreshold: 0.001
        },
        prop: function(f, c){
          return rushH.prop(f, c);
        },
        value: function(t, c){
          return rushH.value(t, c);
        }
      },
      "rush-ltr": {
        direction: 1,
        local: {
          sampleCount: 40,
          errorThreshold: 0.001
        },
        prop: function(f, c){
          return rushH.prop(f, c);
        },
        value: function(t, c){
          return rushH.value(t, c);
        }
      }
    },
    edit: {
      dur: {
        'default': 1
      },
      steep: {
        'default': 0.4,
        type: 'number',
        min: 0,
        max: 1,
        step: 0.01
      },
      offset_near: {
        name: "Offset(Break)",
        'default': 20,
        type: 'number',
        unit: 'px',
        min: 0,
        max: 1000
      },
      offset_far: {
        name: "Offset(Transition)",
        'default': 200,
        type: 'number',
        unit: 'px',
        min: 0,
        max: 1000
      },
      direction: {
        'default': -1,
        type: 'number',
        min: -1,
        max: 1,
        step: 2,
        hidden: true
      },
      percent_in: {
        name: "Duration(Enter)",
        'default': 0.6,
        type: 'number',
        min: 0,
        max: 1,
        step: 0.01
      },
      percent_out: {
        name: "Duration(Exit)",
        'default': 0.8,
        type: 'number',
        min: 0,
        max: 1,
        step: 0.01
      },
      skew: {
        name: "Skew",
        'default': 30,
        type: 'number',
        unit: 'deg',
        min: 0,
        max: 90
      },
      unit: {
        'default': 'px',
        type: 'choice',
        values: ["px", "%", ""]
      }
    },
    timing: function(t, opt){
      var p1, pi, po, near;
      p1 = [0, opt.steep, 1 - opt.steep, 1];
      pi = opt.percent_in;
      po = opt.percent_out;
      if (po < pi) {
        po = pi;
      }
      near = opt.offset_near / opt.offset_far;
      if (t === 0) {
        return -1;
      }
      if (t < pi / 3) {
        t = cubic.Bezier.y(cubic.Bezier.t(t * 3 / pi, p1), p1) * pi / 3;
        return (near + 1) * t / (pi / 3) - 1;
      }
      if (t < pi) {
        t = (t - pi / 3) * 3.75 / pi;
        return near * Math.cos(t * Math.PI) * Math.pow(0.5, t);
      }
      if (t < po || po === 1) {
        return 0;
      }
      return (t - po) / (1 - po);
    },
    css: function(opt){
      var ref$, ref1$, this$ = this;
      return easingFit.fitToKeyframes(function(it){
        return this$.timing(it, opt);
      }, (ref$ = (ref1$ = import$({}, opt.local) || {}, ref1$.config = opt, ref1$), ref$.name = opt.name, ref$.prop = opt.prop, ref$));
    },
    js: function(t, opt){
      return opt.prop({
        value: this.timing(t, opt)
      }, opt);
    },
    affine: function(t, opt){
      return opt.value(this.timing(t, opt), opt);
    }
    /* equivalent keyframes */
    /*
    rush(name, dur, rate, offset_near, offset_far, direction, percent_in, percent_out, skew)
      .{name}
        animation: unquote(name) 1s linear infinite
      @keyframes {name}
        0%
          transform: translate(-1 * direction * offset_far, 0 ) skewX( direction * skew )
          timing-speed-down(rate)
        {percent_in * .37}
          transform: translate( 1 * direction * offset_near, 0)  skewX( -0.78 * direction * skew )
        {percent_in * .56}
          transform: translate( -0.5 * direction * offset_near, 0)  skewX( 0.34 * direction * skew )
        {percent_in * .75}
          transform: translate( 0.25 * direction * offset_near, 0) skew( -0.17 * direction * skew )
        {percent_in * 1}
          transform: translate( 0, 0 ) skew(0deg)
        {percent_out * 1}
          transform: translate( 0, 0 ) skew(0deg)
        100%
          transform: translate(direction * offset_far, 0) skewX( direction * skew )
    */
  };
  if (typeof module != 'undefined' && module !== null) {
    module.exports = ret;
  }
  return ret;
})();
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}