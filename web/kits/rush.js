// Generated by LiveScript 1.3.1
var ret;
ret = {
  name: 'rush',
  type: 'animation',
  preset: {
    "rush-btt": {
      dur: 2,
      steep: 0.4,
      offset_near: 20,
      offset_far: 200,
      direction: -1,
      percent_in: 0.6,
      percent_out: 0.8,
      skew: 30,
      unit: 'px',
      sampleCount: 40,
      errorThreshold: 0.001,
      prop: function(f, c){
        return {
          transform: "translate(0," + f.value * c.offset_far * c.direction + c.unit + ")\nskewY(" + f.value * c.skew * c.direction + "deg)",
          opacity: Math.cos(f.value * Math.PI * 0.5)
        };
      },
      value: function(t, c){
        return {
          transform: [1, -Math.tan(t * c.skew * c.direction * Math.PI / 180), 0, 0, 0, 1, 0, -t * c.offset_far * c.direction, 0, 0, 1, 0, 0, 0, 0, 1],
          opacity: Math.cos(t * Math.PI * 0.5)
        };
      }
    },
    "rush-ttb": {
      dur: 2,
      steep: 0.4,
      offset_near: 20,
      offset_far: 200,
      direction: 1,
      percent_in: 0.6,
      percent_out: 0.8,
      skew: 30,
      unit: 'px',
      sampleCount: 40,
      errorThreshold: 0.001,
      prop: function(f, c){
        return {
          transform: "translate(0," + f.value * c.offset_far * c.direction + c.unit + ")\nskewY(" + f.value * c.skew * c.direction + "deg)",
          opacity: Math.cos(f.value * Math.PI * 0.5)
        };
      },
      value: function(t, c){
        return {
          transform: [1, -Math.tan(t * c.skew * c.direction * Math.PI / 180), 0, 0, 0, 1, 0, -t * c.offset_far * c.direction, 0, 0, 1, 0, 0, 0, 0, 1],
          opacity: Math.cos(t * Math.PI * 0.5)
        };
      }
    },
    "rush-rtl": {
      dur: 2,
      steep: 0.4,
      offset_near: 20,
      offset_far: 200,
      direction: -1,
      percent_in: 0.6,
      percent_out: 0.8,
      skew: 30,
      unit: 'px',
      sampleCount: 40,
      errorThreshold: 0.001,
      prop: function(f, c){
        return {
          transform: "translate(" + f.value * c.offset_far * c.direction + c.unit + ",0)\nskew(" + f.value * c.skew * -c.direction + "deg)",
          opacity: Math.cos(f.value * Math.PI * 0.5)
        };
      },
      value: function(t, c){
        return {
          transform: [1, -Math.tan(t * c.skew * -c.direction * Math.PI / 180), 0, t * c.offset_far * c.direction, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
          opacity: Math.cos(t * Math.PI * 0.5)
        };
      }
    },
    "rush-ltr": {
      dur: 2,
      steep: 0.4,
      offset_near: 20,
      offset_far: 200,
      direction: 1,
      percent_in: 0.6,
      percent_out: 0.8,
      skew: 30,
      unit: 'px',
      sampleCount: 40,
      errorThreshold: 0.001,
      prop: function(f, c){
        return {
          transform: "translate(" + f.value * c.offset_far * c.direction + c.unit + ",0)\nskew(" + f.value * c.skew * -c.direction + "deg)",
          opacity: Math.cos(f.value * Math.PI * 0.5)
        };
      },
      value: function(t, c){
        return {
          transform: [1, -Math.tan(t * c.skew * -c.direction * Math.PI / 180), 0, t * c.offset_far * c.direction, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
          opacity: Math.cos(t * Math.PI * 0.5)
        };
      }
    }
  },
  edit: {
    steep: {
      'default': 0.6,
      type: 'number',
      min: 0,
      max: 1
    },
    offset_near: {
      'default': 20,
      type: 'number',
      unit: 'px',
      min: 0,
      max: 1000
    },
    offset_far: {
      'default': 200,
      type: 'number',
      unit: 'px',
      min: 0,
      max: 1000
    },
    direction: {
      'default': -1,
      type: 'number',
      min: -1,
      max: 1,
      step: 2
    },
    percent_in: {
      'default': 0.7,
      type: 'number',
      unit: '%',
      min: 0,
      max: 100
    },
    percent_out: {
      'default': 0.8,
      type: 'number',
      unit: '%',
      min: 0,
      max: 100
    },
    skew: {
      'default': 15,
      type: 'number',
      unit: 'deg',
      min: 0,
      max: 360
    },
    unit: {
      'default': 'px',
      type: 'choice',
      values: ["px", "%", ""]
    }
  },
  timing: function(t, opt){
    var p1, pi, po, near;
    p1 = [0, opt.steep, 1 - opt.steep, 1];
    pi = opt.percent_in;
    po = opt.percent_out;
    if (po < pi) {
      po = pi;
    }
    near = opt.offset_near / opt.offset_far;
    if (t === 0) {
      return -1;
    }
    if (t < pi / 3) {
      t = cubic.Bezier.y(cubic.Bezier.t(t * 3 / pi, p1), p1) * pi / 3;
      return (near + 1) * t / (pi / 3) - 1;
    }
    if (t < pi) {
      t = (t - pi / 3) * 3.75 / pi;
      return near * Math.cos(t * Math.PI) * Math.pow(0.5, t);
    }
    if (t < po) {
      return 0;
    }
    return (t - po) / (1 - po);
  },
  css: function(opt){
    var ref$, ref1$, this$ = this;
    return easingFit.fitToKeyframes(function(it){
      return this$.timing(it, opt);
    }, (ref$ = (ref1$ = opt.local || {}, ref1$.config = opt, ref1$), ref$.name = opt.name, ref$.prop = opt.prop, ref$));
  },
  js: function(t, opt){
    return opt.prop({
      value: this.timing(t, opt)
    }, opt);
  },
  affine: function(t, opt){
    return opt.value(this.timing(t, opt), opt);
  }
  /* equivalent keyframes */
  /*
  rush(name, dur, rate, offset_near, offset_far, direction, percent_in, percent_out, skew)
    .{name}
      animation: unquote(name) 1s linear infinite
    @keyframes {name}
      0%
        transform: translate(-1 * direction * offset_far, 0 ) skewX( direction * skew )
        timing-speed-down(rate)
      {percent_in * .37}
        transform: translate( 1 * direction * offset_near, 0)  skewX( -0.78 * direction * skew )
      {percent_in * .56}
        transform: translate( -0.5 * direction * offset_near, 0)  skewX( 0.34 * direction * skew )
      {percent_in * .75}
        transform: translate( 0.25 * direction * offset_near, 0) skew( -0.17 * direction * skew )
      {percent_in * 1}
        transform: translate( 0, 0 ) skew(0deg)
      {percent_out * 1}
        transform: translate( 0, 0 ) skew(0deg)
      100%
        transform: translate(direction * offset_far, 0) skewX( direction * skew )
  */
};
module.exports = ret;